



# **Requirements**

Continue the application created in [the previous lab](https://profs.info.uaic.ro/~acf/tj/labs/lab_07.html), exposing some functionalities through various Web services.

1.  ✔️ (2p) Create RESTful Web services using **JAX-RS** that allows the interaction with at least one JPA entity, implementing CRUD operations. For example, the application may offer the following services: 
 
    -   _AddDocumentService_ that allows adding a new document;
    -   _UpdateDocumentService_ that allows replacing an existing document;
    -   _DeleteDocumentService_ that allows deleting an existing document from the database.
    -   _ViewDocumentService_ that returns a "list" of the documents there were uploaded. The parameter of the web method will be an identifier for the user. If the parameter is null, then all documents should be considered.
    
    Use JSON for representing consumed or produced data. Comment (using OpenAPI) and test at least one service.
    
2.  ✔️ (1p) Create a **filter** that will act as a cache for the _ViewDocumentService_, storing the parameters of the incoming request and the returned responses. If the documents are modified by the application, reset the cache accordingly. ✔️
    
3.  ✔️ (2p+) Modify the model such that each document has a list of references (its bibliography), each reference being a document existing in the database. Create another service, that will read all the documents and: ✔️
    -   verify that there are no circuits in the corresponding directed graph;
    -   establish a possible chronological order of the documents, based on their bibliography. Consider using an asynchronous implementation, both at the client and container sides.

# **Explanations**

1. For this laboratory, we designed a system for indexing and referencing documents made by a set of users in the system, documents are supposed to be created by the users which are subsequently their authors but, a document can also reference another document made by an author or set of authors. For executing CRUD operations(additions, deletions, interrogations, etc) over the documents, authors, users, and references in the system we have to make calls to the exposed Restful API. The following endpoints, made following the Rest architectural style, are exposed to the user : 

	-	POST	**/api/v1/users/authenticate** -> used for registering an active user into the system, when first registering the user will get the Role of AUTHOR, another role for the designated user will require an admin interaction.
	-  POST	**/api/v1/users/register** -> used for authenticating a user into the system, as a response to the request, a requesting user will receive in the response a JWT generated and signed by the server authority.
	-  GET	**/api/v1/users** -> used for discovering every registered user in the system. This request is protected via the token authorization mechanism. 
	- GET	**/api/v1/users/{accountId}** -> used for getting a certain user account details. This actions also requires ADMIN level rights to complete.
	- DELETE	**/api/v1/users/{accountId}** -> used for deleting a specified user account. This action requires ADMIN level rights to complete.
	- POST	**/api/v1/documents** -> used to create documents and insert them into the system. A newly created document will have as an author the current user who makes a request. The authenticity of the user is ensured by the token provided as a means of authorization since it holds inside of it the unique id of the requesting user.
	- GET	**/api/v1/documents** -> used to get all the documents in the system for every user.
	- GET **/api/v1/documents/me** -> used to get the documents of a requesting user.
	- DELETE	**/api/v1/documents/{documentId}** -> used to delete the document specified by the id. Only one of the authors of the document can delete it.
	-  POST	**/api/v1/documents/{docId}/authors** -> used for adding another author to the document. Only one of the existing authors can add another author to the document. As a side effect of this action, the author that is being added also gets read and write rights over the document.
	- POST	**/api/v1/documents/{docId}/references** -> used for adding references towards another documents for on of the requesting user's documents. **The action of adding a reference to the document will be validated as to not introduce circular references.**
	- DELETE	**/api/v1/documents/{docId}/references/{referenceId}** -> used for deleting on the references from the requesting document specified by id. This action can also only be completed by one of the documents' authors.
	- DELETE **/api/v1/documents/{docId}/authors/{authorId}** -> used for deleting on the authros from the requesting document specified by id. This action can also only be completed by one of the documents' authors.
	- POST	**/api/v1/contests** -> used for creating contests. **A contest is a competition where different authors can add their documents for review. The documents in the competition can only be reviewed by an account with REVIEWER role**.
	- DELETE	**/api/v1/contests/{contestId}** -> used for deleting a contest. **Only an account with ADMIN role can perform this action**.
	- GET	**/api/v1/contests/{contestId}** -> used for getting the contest details such as the name, if it is still running, etc.
	- PUT	**/api/v1/contests/{contestId}** -> used for changing the properties of a contest. This action is necessary to be performed once the timeframe dedicated to that competition ended for changing the running status of the contest.
	- GET **/api/v1/contests/{contestId}/documents/{documentId}** -> used for getting a specific document enrolled in a contest.
	- GET **/api/v1/contests/{contestId}/documents** -> used for getting all the documents enrolled in a contest. Only a **REVIEWER** can get the documents in a contest. 

The implemented application which exposes a Restfull API works by making use of implementation over the JAX-RS specification. The entry point of our application is the class [`ApplicationConfig`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/ApplicationConfig.java) where we extend the primary Application class and add our resource classes to the set of application resources. We need to specifically add the resource classes which are classes where we used the annotation defined by the JAX-RS specification to indicate the application which instances to bind by their providers at runtime. We also define a class called [`ApplicationResource`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/ApplicationResources.java) (not to be confused with resources of the API Application class) to act as a producer for our EntityManager related to our persistence API definition, we do this cause we want to inject our EntityManager directly in our [`Repositories`](https://github.com/IonitaCatalin/JavaTechnologies/tree/main/Labs8/src/main/java/com/javatech/labs8/repository) classes. 

To bind a certain method to an endpoint in our API we decided to pack this functionality in a few [`Controller`](https://github.com/IonitaCatalin/JavaTechnologies/tree/main/Labs8/src/main/java/com/javatech/labs8/controller) classes such as [`UserController`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/controller/UserController.java), [`DocumentController`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/controller/DocumentController.java), [`ContestController`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/controller/ContestController.java) in a MVC architectural style. A controller's sole purpose is to bind a certain method using the JAX-RS annotation such as @Path(), @GET, @POST, @PUT to an endpoint in our API. Every controller has its associated [`Service`](https://github.com/IonitaCatalin/JavaTechnologies/tree/main/Labs8/src/main/java/com/javatech/labs8/service) class which is injected directly into the controller. The method inside the controller is called when an HTTP request is made at that specific endpoint bound inside the controller, the controller will call the method inside the service which will use one of the Repository classes to further propagate the requested changes in the database. When a request arrives the POST data inside the respective request is marshmallowed in a class desired by the developer. In our case, all the data coming from the user is marshmallowed inside one of our [`DTOs`](https://github.com/IonitaCatalin/JavaTechnologies/tree/main/Labs8/src/main/java/com/javatech/labs8/dtos) classes. For instance, the [`DocumentAddDTO`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/dtos/DocumentAddDTO.java) class contains the pieces of information required by the system to create a document, pieces of information that have to be delivered by the user. Each service gets as an argument an instance of a DTO object and also returns one or multiple instances to be returned as a response from the API.

A response returned by the API has the following structure:
```
{
	status:[SUCCESS or FAILURE]
	message: [String containing the error or success message]
	data: [Entity or array of entities as requested]
}
```


For implementing the functionality offered by the Service, Entities were created to model the data inside our application and to control the relationships between respective entities. The data models of our application are defined using JPA specifications and annotations. Entities are transactionally transferred between runtime instance to the database using method defined in each Repository class specific to each entity such as [`AccountRepository`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/repository/AccountRepository.java), [`DocumentRepository`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/repository/DocumentRepository.java), [`ContestRepository`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/repository/ContestRepository.java). The service classes use by injection the repository instances.

-	[`Account`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/entity/Account.java) -> used for database entries about users, mainly their username and password
-	[`Document`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/entity/Document.java) -> used for storing database entries about the documents available in the system, the Document entity participate in a **one-to-many** relationship with the Account entity, as a document can have one or many users as its author. Also, one Document can have one or many references towards other documents thus it participate in a **one-to-many** relationship with itself.
-	[`Contest`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/entity/Contest.java) -> used for storing database entries about the contest available for enlisting documents in the system, the Contest entity participate in **one-to-many** relationship with the Document entity, as a contest can have one or many Document as participating in that specific contest.

For ensuring the security of our application when opted for a JWT Authorization Schema where when a user logs in he receives back a token issued by the server but with a time limit attached to itself. As a request in a Restfull API has to be self-sufficient token, the transport the id of the logged user inside of it. Over this mechanism, we implemented a Role-based authentication to ensure that some actions can be performed by accreditated personnel. Currently, there are 3 roles available in the system: **REVIEWER, AUTHOR, ADMIN** each with its perks. For implementing this security mechanism we used a few filters precisely: [`AuthenticationFilter`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/filters/AuthenticationFilter.java) and [`AuthorizationFilter`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/filters/AuthorizationFilter.java). Those 2 filters are annotated as providers for the [`JWTTokenRequired`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/annotations/JWTTokenRequired.java) JAX-RS interface. We used this interface to expand over the functionality offered by JAX-RS and to specify which route in our controller we want to have secured with a JWT authorization. [`AuthenticationFilter`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/filters/AuthenticationFilter.java) is the first filter that will be fired in the case of a marked secured route, its job is to extract the token and validate it in the presence of our system's token private key. If the token is indeed valid the filter will pass the context to the next filter but not before overriding the current security context to make it available for the AuthenticationFilter to get the user's id out of it. [`AuthorizationFilter`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/filters/AuthorizationFilter.java) is the second filter that will be fired in the case of a marked secured route, its job is to check if the user has the required role to perform the requested action. 

In case something in the procurement of the current request goes wrong the API will send an error response as a result of an internal exception being thrown. As we intended to raise the responsibility of processing the error thrown by the service classes in the controllers, we used the ExceptionMappers available as functionality inside JAX-RS to send a response when a particular error is thrown. For managing this behaviour we made a particular exception [`TranslatableException`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/exceptions/translatables/TranslatableException.java) which denotes a particular exception convertible to HTTP response, then extended that particular exception for each important HTTP error code such as [`TranslatableBadRequestException`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/exceptions/translatables/TranslatableBadRequestException.java) , [`TranslatableNotFoundException`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/exceptions/translatables/TranslatableNotFoundException.java), etc. For this set of exception mappers for each one of them was built to translate the content of an error to an adequate HTTP response, mappers such as [`TranslatableBadRequestMapper`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/exceptions/mappers/TranslatableBadRequestMapper.java), [`TranslatableConflictMapper`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/exceptions/mappers/TranslatableConflictMapper.java). Once we have mapper in place and generic extensions to cover our use-case scenario all that is left is to define our common error in the application to extends the translatable errors and to send via the error properties string messages to the mappers, exception classes such as [`AccountAlreadyExistsException`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/exceptions/AccountAlreadyExistsException.java).


`2`. For caching requests for a certain amount of time or until a certain revalidation occurs we defined an @interface called [`CacheControlConfig`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/annotations/CacheControlConfig.java) with its provider [`CacheControlFactory`](https://github.com/IonitaCatalin/JavaTechnologies/blob/main/Labs8/src/main/java/com/javatech/labs8/cache/CacheControlFactory.java). The is used with the inbuild CacheControl functionality in the JAX-RS implementation.  


`3`.  As we do not intend to introduce circular dependencies inside our database in the case of references, we have to introduce additional checks to satisfy this condition. The approach we decided to take is before adding other references in the database we load the existing references in a Graph data structure and run a DFS walk in the aforementioned Graph to see if there is any cycle in, if we found a cycle in then introducing that reference might lead to a circular reference and as a consequence, we throw an error. The implementation for our DFS search inside a Graph data structure can be found inside the [`ReferencesGraph`](https://github.com/IonitaCatalin/JavaTechnologies/tree/main/Labs8/src/main/java/com/javatech/labs8/graph) class.




